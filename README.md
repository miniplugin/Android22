## v1.0.0 ~ v6.0.0
 
---

- [학습목차](https://github.com/miniplugin/human22)
- 교사정보: 김일국, boramcom@daum.net, 010-8175-6075
- [NCS강의사용법]클릭, 예) [v1.0.0] <- 아래에서 해당부분 클릭하시면 NCS학습모듈 검색으로 이동합니다.  

---

### [v1.0.0](https://ncs.go.kr/unity/th03/ncsSearchMain.do) UI디자인 (2001020707_17v2)
- v1.0.0 학습목표(과제물v1_한줄일기장_화면설계_학생명.pptx 파일을 작성하여 제출)
- UI 아키텍처 설계 후 시각적인 요소를 디자인하기 위해 비주얼 디자인 콘셉트를 도출하며<br> 이 콘셉트에 근거하여 GUI 상세 디자인을 할 수 있습니다. 

### [v2.0.0](https://ncs.go.kr/unity/th03/ncsSearchMain.do) UI/UX 요구분석 (2001020704_17v2)
- v2.0.0 학습목표(과제물v2_한줄일기장_화면설계_학생명.pptx 파일을 작성하여 제출)
- 사용자리서치 자료를 토대로 사용자의 요구사항을 파악하고 기획된 아이디어를 신속하게<br> 만들어서 시각화하여 테스트할 수 있다. 

### [v3.0.0](https://ncs.go.kr/unity/th03/ncsSearchMain.do) UI/UX 콘셉트 기획 (2001020705_14v1)
- v3.0.0 학습목표(과제물v3_한줄일기장_화면설계_학생명.pptx 파일을 작성하여 제출)
- UI/UX 분석 결과를 바탕으로 UI/UX 콘셉트를 도출하고 기능 및 콘텐츠를 정의할 수 있다. 

### [v4.0.0](https://ncs.go.kr/unity/th03/ncsSearchMain.do) UI아키텍처 설계 (2001020706_14v1)
- v4.0.0 학습목표(과제물v4_한줄일기장_화면설계_학생명.pptx, <br> 과제물v4_한줄일기장_아키텍처_학생명.xlxs 2개 파일을 작성하여 제출)
- 기획된 콘셉트를 바탕으로 디자인과 구현을 위한 콘텐츠, 정보, 와이어 프레임,<br> 태스크 플로우를 설계할 수 있다.

### [v5.0.0](https://ncs.go.kr/unity/th03/ncsSearchMain.do) UI구현 (2001020708_17v2)
- v5.0.0 학습목표(과제물v5_한줄일기장_화면설계_학생명.pptx 파일에서 <br>각 액티비티에 해당하는 핵심 자바소스 코드 입력 후 제줄)
- UI 설계 산출물과 GUI 디자인 가이드를 바탕으로 UI 구현 표준을 수립하고 UI를 제작할 수 있다.

### [v6.0.0](https://ncs.go.kr/unity/th03/ncsSearchMain.do) UI테스트 (2001020709_17v2)
- v6.0.0 학습목표(구글문서로 과제물 제출)
- 구현된 UI를 검증하기 위하여 사용성 테스트 계획, 수행, 분석, 결과 보고를 수행 할 수 있다. 
- 참고자료 휴리스틱평가 : https://drive.google.com/file/d/1ElWz37VM-kiYdoFmIHgSJr2VNapGp3Tg/view?usp=sharing

### 앱 수업에서는 아래 3단계로 진행 됩니다.
- 파트1:01-01-01(안드로이드 개요) ~ 01-03-01~03(슬라이드교육)
- 파트3:(한 줄 일기장): 화면디자인, 앱 기획, 화면구성, 화면구현, 위치/날씨/사진찍기 기능, 데이터베이스연동
- 파트2:02-02-01(레이아웃) ~ 02-05-13(화면구현마지막)

- 참고내용: https://theorydb.github.io/review/2020/04/03/review-book-doit-android-10/#%ED%99%94%EB%A3%A1%EC%A0%95%EC%A0%90-%ED%95%9C-%EC%A4%84-%EC%9D%BC%EA%B8%B0%EC%9E%A5-%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0

### Do It 안드로이드스튜디오 동영상 강의 요약
- 번호선언방식: 파트번호-챕터번호-섹션번호(예, 02-01-01)
- 애플리케이션 4대구성요소: 액티비티,서비스,브로드캐스트리시버,콘텐트 프로바이더
- https://www.youtube.com/playlist?list=PLG7te9eYUi7sjJzJR2i5m6wv-X_7K2pVE
- ----------------------------------
- 01-01-01 안드로이드 개요
- 01-02-01 안드로이드 스튜디오 설치
- https://drive.google.com/file/d/1X9wu2DCLJBbyuZ6BsIxV4U7wLsn-t6WW/view?usp=sharing
- -----------------------------------
- 01-03-01~03 슬라이드로 교육 https://slidesplayer.org/slide/14087618/
- -----------------------------------
- 02-01-01 이론: 작업화면 사용 설명
- 02-01-02 이론: 뷰 정의, XML 형태
- 02-01-03 이론: 위젯 가이드라인으로 위치, 크기지정
- -----------------------------------
- 02-02-01 레이아웃: 이론
- 02-02-02 레이아웃: 제약(Constraint) 레이아웃(화살표) Convert 레이아웃
- 02-02-03 레이아웃: 리니어 레이아웃(Orientation 정렬하기)
- 02-02-04 레이아웃: 리니어 레이아웃(weight 공간분할)
- 02-02-05 레이아웃: 프레임 레이아웃(이미지 교체하기)
- 02-02-06 레이아웃: 스크롤뷰 만들기
- -------------------------------------
- 02-03-01 위젯, 드로우어블 이미지 만들기 시작
- 02-03-02 텍스트뷰, 버튼, 체크박스, 라디오버튼 만들기
- 02-03-03 입력상자(키패드변경) 만들기
- 02-03-04 drawable(상태 드로우어블): selector drawable 클릭한(눌린) 상태
- 02-03-05 drawable(상태 드로우어블): shape drawable 도형
- 02-03-06 이벤트 전달 개요
- 02-03-07 이벤트 Touch(터치) 처리
- 02-03-08 이벤트 Gesture(체스쳐) 처리
- 02-03-09 방향전환 화면 만들기: layout-land 폴더생성
- 02-03-10 방향전환 해도 입력값이 변하지 않게하기 1
- 02-03-11 방향전환 해도 입력값이 변하지 않게하기 2
- 02-03-12 토스트 디자인 바꾸기 방식3가지 스낵바(Snackbar) | 대화상자(AlertDialog)
- 02-03-13 프로그레스 바 만들기(막대형, 원형)
- --------------------------------------
- 02-04-01 레이아웃 파일이 자바소스(Context)파일에서 뷰를 inflate됨(렌더링)
- 02-04-02 부분화면(xml) 추가하고, LayoutInflater로 화면에 출력(메모리로딩)
- 02-04-03 여러개 화면전환하기: Intent 메세지 오브젝트로 데이터 전달 및 리턴받기(화면고유요청코드필요)
- 02-04-04 인텐트사용 putExtra("key","value"); -> getStringExtra("key");
- 앱구성요소4(인텐트사용): 액티비티(화면), 브로드캐스트(카톡메세지수신),서비스(백그라운드실행-비화면), 콘텐트 프로바이더(Db데이터전송/수신)
- 02-04-05 Intent사용예, startActivity("명시적-activity,암시적-intent"); 액티비티 스택 intent.setFlags(FLAG_ACTIVITY_SINGLE_TOP);
- 02-04-06 Bundle에 인텐트 데이터를 넣어서 전달/수신함 (VO클래스도 전달가능)
- 02-04-07 VO클래스 implements Parcelable 인텐트로 전달하기(사용안함) -> 대신 VO클래스 Serialize사용.(Task:브로드캐스드수신에사용)
- 02-04-08 라이프사이클: 스마트 앱을 실행하다가, 전화가 왔을때(onPause) 기존 앱상태(onResume) 저장이 필요(간단한저장=SharedPreferences,대량저장=Db사용).
- 라이프사이클에서 자동실행: onCreate(생성)-onDestroy(소멸), onStart(시작)-onStop(정지), onResume(실행)-onPause(일시정지)
- Log.d("System.out.println()과 같음");
- 저장기능(아래)
- SharedPreferences pref = getSharedPreferences("저장클래스변수명", Activity.MODE_PRIVATE);
- SharedPreferences.Editor editor = pref.edit();
- editor.putString("저장키변수명", editText.getText().toString());
- editor.commit(); //파일로 저장되기 때문에 앱이 종료되더라도 다시 불러올 수 있다.
- 불러오기기능(아래)
- SharedPreferences pref = getSharedPreferences("저장클래스변수명", Activity.MODE_PRIVATE);
- pref.getString("저장키명","디폴트값");//디폴트값이 null 이라면, 저장된 값이 들어옵니다.
- editText.setText(저장키명);
---------------------------------------
- 위 까지는 액티비티 매니저(ActivityManager안드로이드 시스템기반)에서 화면관리(인텐트로 다른화면 호출)
- 아래 부터는 프레그먼트 매니저(액티비티기반)에서 화면관리(메소드로 다른화면 호출)
---------------------------------------
- 02-05-01 프레그먼트(fragment): 레이아웃 안에 레이아웃을 넣는 방식
- 자바의 레이아웃템플릿의 include 와 같이 view재사용 역할
- 프레그먼트 추가방법2가지: xml로 추가 또는, 자바에서 inflate로 추가
- 02-05-02 xml로 추가로 만들기(extends Fragment): onCreateView(){return inflate(뷰xml)로 연결}
- 02-05-03 자바 inflate로 만들기
- mainFrament = (MainFragment) getSupportFragmentManager().findFragmentById(R.id.mainFragment);
- menuFragment = new MenuFragMent();
- 02-05-04 프레그먼트의 생명주기(LifeCycle)
- onAttach(생성)-onDetach(소멸), onCreate(생성)-onDestroy(소멸)
- 라이프사이클에서 자동실행: onCreteView(inflattion)=onDestroyView(출력), onStart(시작)-onStop(정지), onResume(실행)-onPause(일시정지)
- 실습예, 화면 2개로 분할(이미지버튼 프레그먼트, 이미지뷰 프레그먼트)
02-05-05 실습예, 이미지뷰 프레그먼트 제작 및 구현 ImageSelectionCallback Interface 사용. 메인화면에 onImageSelected() 메서드 추가
02-05-06 실습예, if(context instanceof ImageSelectionCallback){메인액티비티가 이미지콜백의 오브젝트와 같다면...}
- 액션바사용(기본타이틀, 옵션메뉴, 버튼, 검색등등): res/menu폴더명약속/menu Resource file(xml) 
- 02-05-07 옵션메뉴만들기:소스콘텍스트메뉴> Generate(Override Method)> 컨트롤키 누른상태에서 onCreateOptonsMenu(메뉴설정), onOptionsItemSlected(메뉴선택구현)
- 02-05-08 액션바 + 상단탭메뉴만들기(팔레트>Container>AppBarLayout 머티어리얼 추가)
- 02-05-09 액션바 + 상단탭메뉴만들기(CoordinatorLayout코디네이터사용)
- values/styles.xml> <style ... parent="Theme.AppCompat.Light.NoActionBar">사용
- 탭메뉴와 프레그먼트 클래스 3개 불러오기
- 02-05-10 setSupportActionBar(툴바);//사용자생성툴바넣어줌
- tabs.addOnTabSelectedListener(new TabLayout.OnTabSelected) {자동메서드생성}
- 하단탭: bottomNavagationView 위젯(메뉴xml 을 inflation 시킴)
- 02-05-11 하단탭: 팔레트>Container>BottomNavigationView 머티어리얼 추가
- 02-05-12 뷰페이저(액태비티좌우스크롤): 어댑터기반으로 프레그먼트 관리 및 화면출력
- 팔레트>Container>ViewPager 추가 후 Context(자바)에서(아래 추가)
- class PagerAdapter extends FragmentStatePagerAdapter {...}
- { ArrayList<Fragment> items = new ArrayList<Fragment>();//프레그먼트 배열로 추가 }
- 02-05-13 바로가기(햄버거)메뉴: new 액티비티중 Navigation Drawer Activity 자동등록 내용만 확인
- 상단(햄버거메뉴, 타이틀, 옵션메뉴), 본문, 하단(플로팅액션버튼-스낵바출력)
---------------------------------------
- 02-06-01 서비스와 브로드캐스트 수신자.(사용예, 카톡 푸시 메시지)
- startService();//화면없이 백그라운드에서 동작. 시스템구성요소는 manifest에서 알고 있어야함.
- 02-06-02 인텐트로 서비스 시작시킴.
- 프로젝트 선택 후 New > 서비스 생성.
- Intent intent = new Intent(실행위치, 실행대상);
- intent.putExtra("command", "show");
- intent.putExtra("name", name);
- startService(intent);
- @Override onNewIntent(Intent intent) {} 호출
- 02-06-03 브로드캐스트 수신자(리시버): 앱구성요소는 인텐트로 메시지 전송.
- SmsReceiver 등록: 프로젝트 선택 후 New > Others > 리시버를 등록해 놓는다.
- manifest: <intent-filter> 메시지중 필터에 해당하는 것만 받겠다.
- Bundle bundle = intent.getExtras();
- SmsMessage[] message = parseSmsMessage(bundle);
- 02-06-04 파싱: message[cnt] = SmsMessage.createFromPdu((byte[]) obj[cnt]);
- Build.VERSION.SDK_INT >= Build.VERSION.CODES.M : 안드로이드 버전확인
- <uses-permission android:name="android.permission.RECEIVEW_SMS"/>
- 위험권한은 인증해 주는 코드가 필요하지만, 자동인증창이 나오게 하는 jitpack.io 외부 라이브러리 추가
- Sync Now = 상단 코끼리 모양 아이콘
- 02-06-05 메인액티비티에 퍼미션 클래스 상속부분 추가
- implements AutoPermissionsListener
- AutoPermissions.Companion.loadAllPermissions(this, 101);
- 02-06-06 SMS메세지 내용 인텐트 Extras로 받아서 화면에 뿌려줌.
---------------------------------------
- 02-07-01 리스트 만드는 과정(세로데이터에 강점:어댑터로 데이터 바인딩후 item선택기능)
- 예전엔 ListView -> 지금은 RecyclerView 사용
- [리사이클러뷰의 장점]
- 1. 리스트뷰와 다르게 상하 스크롤 뿐만 아니라 좌우 스크롤도 가능하게 할 수 있다
- 2. 각의 아이템이 화면에 보여지는 과정에서 화면에 보이는 과정에서 메모리를 절약할 수 있게 구조가 되어있다. 레이아웃 매니저(LayoutManager)와 뷰홀더패턴(View Holder Pattern)을 의무화했다.
- (리스트뷰도 뷰홀더를 이용해 캐시 매커니즘을 사용할 수는 있지만 리사이클러뷰는 이를 의무화함)
- 3. 리스트뷰보다 다양한 형태로 커스터마이징하기 쉽다.
- 4. RecyclerView 예제: https://webnautes.tistory.com/1214
- 나인패치 이미지 버튼에 적용하기
- 02-07-02 뷰만들기(뷰종류:모양이 있는 위젯, 모양이 없는 레이아웃)
- 뷰를 상속(Superclass)해서 버튼 만들기.
- Context(xml에 대한 정보를 담는 클래스)
- 02-07-03 뷰를 상속해서 레이아웃 만들기: 카드뷰
- 02-07-04 리니어레이아웃을 상속해서 카드뷰 만들기. LayoutInflater inflater.inflate(xml명, this, true)형식으로 xml과 context연결
- onCreate()의 setContentView와 같은 역할.
- 02-07-05 inflate() 로 생성된 레이아웃의 이미지를 바꾸기, Container > 카드뷰 라이브러리 추가
- <androidx.cardview.widget.CardView>카드뷰로 inflate() 레이아웃을 감싸준다.</CardView>
- 02-07-06 리사이클러뷰 사용해서 스크롤되는 뷰 만들기: 어댑터에 리스트에 들어가는 데이터를 담는 클래스 생성
- 리사이클러뷰에 들어가는 뷰를(itemView)을 담아 놓는 뷰홀더 클래스 생성
- public ViewHolder(View itemView) { }
- 02-07-07 public void onBindViewHolder(ViewHolder holder, int pos){Person item = items.get(pos);holder.setItem(item);}
- 02-07-08 작업과정 3가지(아래)
- person_item.xml(리스트에서 각 item을 위한 xml레이아웃화면 제작)
- PersonAdapter.java(리스트에서 각 item에 데이터를 담을 클래스 제작)
- LayoutManager 사용(사용이유: 유지보수가 편리함)
- 02-07-09 인터페이스 OnPersonItemClickListener 사용해서 item클릭 메서드 구현.
- 이벤트처리방식: 리스너정의 -> 어댑터의 item클릭 이벤트 -> 리스너 인터페이스 사용.
- 02-07-10 뷰페이저, 스피너(셀렉트콤보박스:데이터바인딩 어댑터사용)
---------------------------------------
- 02-08-01 트윈(twin)애니메이션xml기반(시작이미지->이동->끝이미지)의 위젯 사용
- 02-08-02
- 02-08-03
- 02-08-04
- 02-08-05
---------------------------------------
- 02-09-01 쓰레드사용 핸들러로 UI업데이트(시퀸스작업의 반대=동시작업:병렬작업)
- onCreate()에서 아래 3줄 사용
- 1) BackgroundThread thread = new BackgroundThread();
- 2) thread.start();
- 3) handler = new MainHandler();
- class BackgroundThread extends Thread { public void run() {...} }
- 스레드에서 view에 값을 바로 넣을 수 없기 때문에 위 {...} 안쪽에 아래 2줄로 처리
- 1) Message message = handler.obtainMessage();//Intent와 비슷
- 2) Bundle bundle = new Bundle();//인텐트와 비슷
- 02-09-02 앱 메인쓰레드와 사용자쓰레드가 뷰에 동시에 접근할 수 없는 문제 해결.
- 스프링에서는 자동으로 처리해 주지만, 안드로이드에서는 핸들러로 처리해야 함.
- class MainHandler extends Handler {...}
- 위 방식은 너무 혼란스럽기 때문에 핸들러를 상속하지 말고 Thread안에 아래처럼 처리
- handler.post(new Runnable() {...public void run() {...} });
- 02-09-03 AsyncTask 로 쓰레드안에 코드와 화면갱신용 핸들러 사용하는 작업단위
- AsyncTask 실습 프로그레시바 위젯으로 값 증가처리.
- class BackgroundTask extends AsyncTask<Integer, Integer, Integer> {.쓰레드 실행전, 후, doInBackground실행=UI업데이트..}
- AsyncTask 실행은 아래처럼.
- 1) BackgroundTask task = new BackgroundTask();
- 2) task.execute();
---------------------------------------
- 02-10-01 네트워크 프로그래밍(스프링 프로젝트 RestAPI와 연동된작업으로 대체)
- 소켓통신 + 스레드사용 핸들러로 UI업데이트
- 2-tier(C/S모델), 3-tier(Client/응용Server/데이터Server)
- Volley라이브러리사용해서 스레드사용 핸들러처리를 대체.
- json타입 -> gson 라이브러리로 json데이터를 객체화 후 데이터처리.
- 02-10-02 소켓 테스트용 1개 액티비티에 클라이언트 - 서버 구성하기.
- final 로 변수를 선언하면, 스레드 메서드 내 에서도 사용 가능하다.
- 02-10-03 클라이언트 소켓연결 및 데이터 전송(아래)
- Socket sock = new Socket("localhost", 5001);
- ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutperStream());
- outstream.writeObject(data);
- outstream.flush();//버퍼 비우기
- ObjectInputStream instream = new ObjectInputStream(sock.getInperStream());
- String input = (String) instream.readObject();
- sock.close();//자원반납
- 서버시작(아래)
- new Thread(new Runnable() { @Override public void run(){startServer();} } );
- ServerSocket server = new ServerSocket(port);
- while(true) {
- Socket sock = server.accept();
- InetAddress clientHost = sock.getLocalAddress();
- int clientPort = sock.getPort();
- ObjectInputStream instream = new ObjectInputStream(sock.getInperStream());
- String input = (String) instream.readObject(); 
- println("수신데이터: " + input);
- ObjectOutputStream outstream = new ObjectOutputStream(sock.getOutperStream());
- outstream.writeObject(input);
- outstream.flush();//버퍼 비우기
- println("데이터보냄:");
- sock.close();
- }
- 02-10-04 핸들러 사용해서 UI업데이트
- public void println(String data) {
- handler.post(new Runnable() {
- @Override public void run() {
- output1.append(data + "\n");
- }
- }
- }
- 02-10-05 실무에서는 소켓(항상연결)방식 보다는 웹 방식(RestAPI)이 많이 사용됨.
- HttpURLConnection conn = (HttpURLConnection) url.openConnection();
- manifest파일: <application android:usesCleartextTraffic="true" ... 추가/>
- 02-10-06 HttpURLConnection 대신에 Volley 라이브러리 사용함(핸들러 필요없음).
- build.gradle[app] 에서 dependencies 의존성 추가.
- 볼리사용법(아래)
- 1.요청객체 만들기: StringRequest request = new StringRequest(
- Request.Method.GET,
- RestApi주소문자,
- new Response.Listener<String>() {
- @Override public void onResponse(String response) {
- 
- }
- },
- new Response.ErrorListener() {
- @Override public void onErrorResponse(VolleyError error) {
- 
- }
- }
- ){
- 콘텍스트메뉴->generator>Override Method>getParames선택
- };
- request.setShouldCache(false);//요청보내고 캐시 지우기
- requestQueue.add(request);//Volley로 요청보냄 실행.
- static RequestQueue requestQueue;
- 2. onCreate()내 추가 requestQueue = Volley.newRequestQueue(getApplicationContext());
- 02-10-07 gson 라이브러리로 json데이터 파싱하기(값을 하나씩 뽑아내기)
- 02-10-08 json데이터에 맞는 VO클래스 만들기(MovieListResult, MovieList, Movie)
- Gson gson = new Gson();
- MovieList movieList = gson.fromJson(response, MovieList.class);
- 02-10-09 리사이클러뷰를 이용해서 데이터를 바인딩해서 화면에 출력하기.
- 어댑터 -> 리사이클러.뷰홀더(itemView) 바인딩
- 영화정보URL: 
- http://www.kobis.or.kr/kobisopenapi/webservice/rest/boxoffice/searchDailyBoxOfficeList.json?key=430156241533f1d058c603178cc3ca0e&targetDt=20200501
---------------------------------------
- 02-11-01 데이터베이스 사용(스마트폰내장-SQLite사용)
- 02-11-02 메인액티비티에 DB만들기, 테이블만들기.(변수활용:변수지정, 값할당)
- SQLiteDatabase database = openOrCreateDatabase(databaseName, MODE_PRIVATE, null);
- String sql = "create table if not exists " + tableName + "(id integer PRIMARY KEY autoincrement, name text, age integer, mobile text)";
- database.execSQL(sql);
- 02-11-03 레코드 추가: 
- String sql = "insert into " + tableName + "(name,age,mobile) values('홍길동',20,'010-0000-0000)";
- database.execSQL(sql);
- 02-11-04 레코드 조회: 관리도구 https://sqlitebrowser.org/dl/ 설치
- 02-11-05 DB Browser for SQLite 프로그램사용(*.db 열기): Device file Explorer메뉴
- 레코드 출력
- String sql = "select id,name,age,mobile from " + tableName;
- Cursor cursor = database.rawQuery(sql, null);
- int recordCount = cursor.getCount();
- for(int cnt=0;cnt<recordCount;cnt++) {
- cursor.moveToNext();
- int id = cursor.getInt(0);
- String name = cursor.getString(1);
- int age = cursor.getInt(2);
- String mobile = cursor.getString(3);
- }
- cursor.close();
- DatabaseHelper클래스 사용(DB생성,커넥션,CRUD를 간편하게 사용하게 도와주는 클래스)
- public class DatabaseHelper extends SQLiteOpenHelper {}
- UX/UI 단원과는 거리가 있기 때문에 아래는 시간이 남으면 진행
- 02-11-06 콘텐트 프로바이더(내용제공자:DAO): 다른 앱에서 데이터를 접근할 수 있도록 함.
- 액티비티(리졸버) -> 프로바이더(DAO) -> 데이터베이스
- ContentProvider는 앱 구성요소이기때문에 manifest.xml에 등록이 필요.(아래)

```
<permission android:name="org.edu.humanapp.READ_DATABASE" android:protectionLevel="normal"/>
<permission android:name="org.edu.humanapp.WRITE_DATABASE" android:protectionLevel="normal"/>
<provider ... />
```
- 스마트폰 내부데이터를 Resolver를 이용해 접근함.(사용예,사진갤러리를 가져올 수 있음)
- Resolver 작동은 프로바이더의 CRUD(insert, query, update, delete)로 구현된 것을 사용.
- content://데이터소스 방식으로 Resolver로 접근.
- 02-11-07 DatabaseHelper클래스 사용 후 프로바이더 클래스 만들기
- 클래스 내부에서 콘텍스트메뉴 > generate > Implement Methods > 2개 생성
- 클래스 내부에서 콘텍스트메뉴 > generate > Constructor > 1개 첫번째 생성
- public class PersonProvider extends ContentProvider {}
- 클래스 내부에서 콘텍스트메뉴 > generate > Implement Methods > 전체 생성
- 02-11-08 프로바이더 클래스의 insert, delete, update메서드, URI(Resolver접근용) 만들기.
- 02-11-09 프로바이더 클래스의 query 메서드 만들기. 
- 메인액티비티에 CRUD호출(아래)
- ContentsValues values = new ContentsValues();
- values.put("name", "홍길동");
- Uri uri = new Uri.Builder().build().parse("contents://org.edu.humanapp/person");
- uri = getContentResolver().insert(uri, values);//프로바이더 구현 메서드 호출
- while(cursor.moveToNext()) {
- String name = cursor.getString(cursor.getColumnIndex(columns[0]));
- int age = cursor.getInt(cursor.getColumnIndex(columns[1]));
- String mobile = cursor.getString(cursor.getColumnIndex(columns[2])) 
- }
- 02-11-10 메인액티비티에서 프로바이더 구현 메서드 호출(queryPerson, updatePerson)
- 02-11-11 액티비티에서 리졸버를 이용해서 앨범갤러리, 연락처에 접근하기.
- Intent 메세지 객체 사용: Intent intent = new Intent();
- intent.setType("image/*");
- intent.setAction(Intent.ACTION_GET_CONTENT);
- Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
- 콘텍스트메뉴 -> generate -> OverrideMethod -> onActivityResult()선택
- ContentResolver resolver = getContentResolver();
- InputStream instream = resolver.openInputStream(fileUri);
- 02-11-12 외장 SD카드접근을 위한 권한 설정(위험권한 자동부여)
- 일반권한, 위험권한 기술참조: https://programmingnote.tistory.com/24
- app gradle 에서 추가: repositores { maven{ url 'https://jitpack.io' } }
- implementation 'com.github.com.pedroSG94:AutoPermissions:1.0.3' 의존성 추가
- 02-11-13 ContentResolver를 이용해서 연락처프로바이더에서 연락처 정보 가져오기
- cursor 사용
- cursor = getContentResolver().query(ContactsContract.Data.CONTENT_URI, null, ...)
- 향상된 for문사용
- for(String column:columns) {
- int index = cursor.getColumnIndex(column);
- String columnOutput = ("#"+index+":["+column+"]"+ cursor.getString(index);
- }
---------------------------------------
- 02-12-01 그래픽처리(ondraw()를 호출하여 뷰영역을 다시 그리게 하는 함수)
- 02-12-02
- 02-12-03
- 02-12-04
- 02-12-05
- 02-12-06
- 02-12-07
- 02-12-08
---------------------------------------
- 02-13-01 멀티미디어처리(인터넷전화:마이크음성저장, 영상통화)
- 카메라앱사용
- 02-13-02
- 02-13-03
- 02-13-04
- 02-13-05

### 잠고자료.
- [NCS학습모듈] https://ncs.go.kr/unity/th03/ncsSearchMain.do